// [시뮬레이션 + 백트래킹(완전탐색)]
// 1. 크기가 N×N인 지도가 있다.지도의 각 칸에는 그 곳의 높이가 적혀져 있다.
// 2. 오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.
// 3. 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다.
// 4. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다.또, 개수는 매우 많아 부족할 일이 없다.
//    경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.
//    4-1. 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
//    4-2. 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
//    4-3. 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
// 5. 아래와 같은 경우에는 경사로를 놓을 수 없다.
//    5-1. 경사로를 놓은 곳에 또 경사로를 놓는 경우
//    5-2. 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
//    5-3. 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
//    5-4. 경사로를 놓다가 범위를 벗어나는 경우
// 6. 지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.
// 7. 첫째 줄에 N(2 ≤ N ≤ 100)과 L(1 ≤ L ≤ N)이 주어진다.
// 8. 둘째 줄부터 N개의 줄에 지도가 주어진다.각 칸의 높이는 10보다 작거나 같은 자연수이다.
// 9. 첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


// 1. 크기가 N×N인 지도가 있다.지도의 각 칸에는 그 곳의 높이가 적혀져 있다.
// 7. 첫째 줄에 N(2 ≤ N ≤ 100)과 L(1 ≤ L ≤ N)이 주어진다.
int N, L;
int map[101][101];

// 2. 오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.
bool go(vector<int> &a, int l) {
	int n = a.size();

	vector<bool> c(n, false);
	
	// 3. 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다.
	// 4. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다.또, 개수는 매우 많아 부족할 일이 없다.
	//    경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.
	//    4-1. 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
	//    4-2. 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
	//    4-3. 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
	// 5. 아래와 같은 경우에는 경사로를 놓을 수 없다.
	for (int i = 1; i < n; i++) {
		if (a[i - 1] != a[i]) {
			int diff = a[i] - a[i - 1];
			if (diff < 0)    diff *= -1;
			//    5-2. 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
			if (diff != 1)   return false;
			if (a[i - 1] < a[i]) {
				for (int j = 1; j <= l; j++) {
					//    5-4. 경사로를 놓다가 범위를 벗어나는 경우
					if (i - j < 0)   return false;
					//    5-3. 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
					if (a[i - 1] != a[i - j])    return false;
					//    5-1. 경사로를 놓은 곳에 또 경사로를 놓는 경우
					if (c[i - j])  return false;
					c[i - j] = true;
				}
			}
			else {
				for (int j = 0; j < l; j++) {
					//    5-4. 경사로를 놓다가 범위를 벗어나는 경우
					if (i + j >= n)    return false;
					//    5-3. 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
					if (a[i] != a[i + j])  return false;
					//    5-1. 경사로를 놓은 곳에 또 경사로를 놓는 경우
					if (c[i + j])  return false;
					c[i + j] = true;
				}
			}
		}
	}
	return true;
}

// 6. 지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	// 7. 첫째 줄에 N(2 ≤ N ≤ 100)과 L(1 ≤ L ≤ N)이 주어진다.
	cin >> N >> L;

	// 8. 둘째 줄부터 N개의 줄에 지도가 주어진다.각 칸의 높이는 10보다 작거나 같은 자연수이다.
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> map[i][j];
		}
	}

	int ans = 0;

	// 가로
	for (int y = 0; y < N; y++) {
		vector<int> d;
		for (int x = 0; x < N; x++) {
			d.push_back(map[y][x]);
		}
		if (go(d, L))    ans += 1;
	}

	// 세로
	for (int x = 0; x < N; x++) {
		vector<int> d;
		for (int y = 0; y < N; y++) {
			d.push_back(map[y][x]);
		}
		if (go(d, L))    ans += 1;
	}

	// 9. 첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.
	cout << ans << '\n';


	return 0;
}